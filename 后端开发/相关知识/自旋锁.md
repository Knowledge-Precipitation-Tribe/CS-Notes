# 什么是自旋锁
在程序没有抢到锁的情况下，程序通过无限循环一直去抢占锁，除非当前线程时间到了，被迫让出CPU，但是当前堪称不会阻塞，仍处于就绪状态，等待下一次的调度，进入CPU继续抢占锁。

自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。

因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。由于这个原因，**操作系统的内核经常使用自旋锁**。但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被OS调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。

解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。但是如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要。可以尝试使用适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。

# 会产生的问题
## 不可重入
如果获取锁之后，递归调用进入同一段代码，就会发生问题，也就是不可重入性。为了解决这个就需要每次成功地申请锁以后，要记录到底是谁申请的，还要用一个计数器记录重入的次数，持有锁的家伙再次申请锁只是给计数器加l而己。释放锁的时候也是一样的，把计数器减l，等于0才表示真正地释放锁。

## 空耗cpu
自旋状态会导致cpu被持续空耗，为了解决这个问题有一种新的解决方案，如果抢不到锁就去等待队列里待着，等到锁被别人释放了，再通知去抢。

# 自旋锁的优缺点
自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cpu的线程又不能获取到 cpu，造成cpu的浪费。所以这种情况下我们要关闭自旋锁。
