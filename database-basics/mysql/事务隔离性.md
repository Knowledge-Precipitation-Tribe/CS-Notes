在[[database-basics/mysql/事务]]里面我们提到，事务的并发执行会产生一些问题，他们分别是：
- 脏读：事务A读取了事务B更新后的数据，但是事务B没有提交，然后事务B执行回滚操作，那么事务A读到的数据就是脏数据
- 不可重复读：事务A进行多次读取操作，事务B在事务A多次读取的过程中执行更新操作并提交，提交后事务A读到的数据不一致。
- 幻读：事务A将数据库中所有学生的成绩由A->B，此时事务B手动插入了一条成绩为A的记录，在事务A更改完毕后，发现还有一条记录没有修改，那么这种情况就叫做出现了幻读。
- 丢失修改：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

对于上面可能产生的问题，MySQL有对于事务就存在四种隔离级别：
- 读未提交read uncommitted：读未提交指的是一个事务在提交之前，它所做的修改就能够被其他事务所看到。
- 读已提交read committed：读已提交指的是一个事务在提交之后，它所做的变更才能够让其他事务看到。
- 可重复读repetable read：可重复读指的是一个事务在执行的过程中，看到的数据是和启动时看到的数据是一致的。未提交的变更对其他事务不可见。
- 串行化serializable：顾名思义是对于同一行记录，`写`会加`写锁`，`读`会加`读锁`。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

其中隔离级别由低到高是：读未提交 < 读已提交 < 可重复读 < 串行化。隔离级别越高，越能够保证数据的完整性和一致性，但是对并发的性能影响越大。大多数数据库的默认级别是`读已提交(Read committed)`，比如Sql Server、Oracle，但是MySQL的默认隔离级别是 `可重复读(repeatable-read)`。

以上四种隔离级别分别会解决不同的问题，如下图所示：
![](https://tva1.sinaimg.cn/large/008eGmZEly1godddojdw4j30ac05xmxb.jpg)

但是对于MySQL的InnoDB存储引擎来说，在REPEATABLE-READ（可重读）事务隔离级别下使用的是[[Next-key锁]]算法，因此可以避免幻读的产生，这与其他数据库系统(如SQL Server)是不同的。所以说InnoDB存储引擎的默认支持的隔离级别是REPEATABLE-READ已经可以完全保证事务的隔离性要求，即达到了SQL标准的SERIALIZABLE(可串行化)隔离级别。

