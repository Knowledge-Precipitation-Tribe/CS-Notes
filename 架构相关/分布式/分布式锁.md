# 什么是分布式锁
在分布式环境下，锁定全局的唯一资源，使得请求变为串行化，实际使用中表现为互斥锁。

# CAP理论
[[CAP理论]]

# 为什么要使用分布式锁
- 避免不同节点重复相同的工作
- 避免出现多个节点操作同一个资源，导致资源最终状态出错

# 分布式锁的设计目标
- 要保证强一致性
- 要可以实现锁的自动续约以及锁的自动释放

# 分布式锁的设计方案
## redis
内部不包含一致性算法，实现的AP模型，采用主从复制机制实现高可用，表现形式为setNX。Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。

当且仅当 key 不存在，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。返回值：设置成功，返回 1 。设置失败，返回 0 。

使用SETNX完成同步锁的流程及事项如下：
- 使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功
- 为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间
- 释放锁，使用DEL命令将锁数据删除

Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：
1.  安全特性：互斥访问，即永远只有一个 client 能拿到锁
2.  避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区
3.  容错性：只要大部分 Redis 节点存活就可以正常提供服务

## zookeeper
内部采用paxos算法，实现的CP模型，采用N+1可用的方式，表现形式为createEphemeral。

## etcd
内部采用raft协议，可以实现CP/AP模型，采用N+1可用的方式，对外提供http/grpc接口，表现形式为resuflt api。

# 分布式锁使用的特殊场景
从获得锁到释放锁中间的数据密等等逻辑需要根据业务实践，例如线程A操作订单，先拿到锁，操作之后修改订单状态，然后释放锁。线程B再来操作订单时，可以拿到锁，但是订单状态已经改变了就不进行操作，此时释放锁，通过这样的方式实现数据密等问题。