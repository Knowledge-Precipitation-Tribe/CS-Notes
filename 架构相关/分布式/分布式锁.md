# 一、什么是分布式锁
在分布式环境下，锁定全局的唯一资源，使得请求变为串行化，实际使用中表现为互斥锁。

# 二、CAP理论
任何一个分布式系统都无法同时满足一致性，可用性和分区容错性也就是[[CAP理论]]。

# 三、为什么要使用分布式锁
- 避免不同节点重复相同的工作
- 避免出现多个节点操作同一个资源，导致资源最终状态出错

# 四、分布式锁的设计目标
- 要保证强一致性
- 要可以实现锁的自动续约以及锁的自动释放

# 五、分布式锁的设计方案
## 5.1 数据库实现方案
基于数据库的分布式锁设计方案有三种分别是：表记录，乐观锁，悲观锁。

### 5.1.1 基于表记录的分布式锁
基于这种方式实现分布式锁，我们可以直接创建一张锁表，并通过操作锁表中的记录来实现分布式锁。需要获得锁时，在表中增加一条记录，需要释放锁时，将这条记录删除即可。

存在的问题：
- 我们可以看到，这种锁没有失效时间，若释放锁失败锁记录就会一直保存在数据库，导致其余线程无法获取锁
- 可靠性依赖数据库，数据库挂了就GG
- 实现的分布式锁是非阻塞的，插入数据失败之后会直接报错，想要获得锁还需要再次操作
- 实现的分布式锁是非可重入的，同一个线程在没有释放锁之前无法再次获得锁，因为数据库已经有一份记录了

解决问题：
- 关于问题一，我们可以使用定时任务来进行清理
- 关于问题二，我们可以考虑设置主从库，避免单点
- 关于问题三，我们可以实现一个循环，直至插入记录成功再返回
- 关于问题四，我们可以在数据库增加字段，记录获得锁的主机信息、线程信息等，下次获得锁时先查询数据，若可以查询到当前的主机信息和线程信息，直接将锁分配给它即可。

### 5.1.2 基于乐观锁的实现
[[乐观锁和悲观锁#^261a29|乐观锁]]认为数据的更新在大部分时间内不会产生冲突，只有在数据库更新提交时才对数据作冲突检测。若检测的结果出现了与预期不一致的情况，则返回失败信息。

主流的乐观锁是基于数据版本(version)的记录机制实现的，数据版本即是版本标识，一般在表中增加一个version的字段。在读取数据时，会将版本号一起读出，更新结束后会将版本号加一。在更新过程中会对版本号进行比较，若相同则执行成功，否则本次操作失败。

关于乐观锁实现的优点：
- 不依赖数据库本身的锁机制，不影响请求的性能
- 并发量较少时，只有少部分请求会失败

关于乐观锁实现的缺点：
- 对表的设计增加额外的字段，增加了数据库的冗余
- 并发量较大时，version的值不断变化，大量请求失败
- 在秒杀情况下，大量请求同时请求同一条记录的行锁，给数据库带来压力

综上所述，乐观锁适合并发量不高且写操作不频繁的场景。

### 5.1.3 基于悲观锁的实现
[[乐观锁和悲观锁#^bc89cd|悲观锁]]认为数据总数会发生冲突的，关于使用悲观锁实现分布式锁，可以借助数据库中自带的锁，在查询语句增加FOR UPDATE字段，会给数据库表增加排他锁，即悲观锁。在记录被加上悲观锁后，其他请求无法获得该记录的悲观锁。

使用悲观锁的注意事项：
- 注意锁的级别，不要加上表锁。MySQL InnoDB在加锁时只有明确指定主键或索引才会执行行锁，否则会直接加上表锁
- 需要关闭MySQL的自动提交，否则MySQL会在你执行完一个更新之后将其直接提交，我们需要在FOR UPDATE获得锁之后执行业务逻辑再通过COMMIT释放锁

悲观锁的优点：
- 每一次对记录的访问都是独占的，可以严格保证数据的安全

悲观锁的缺点：
- 每次请求都会额外产生加锁的开销
- 未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞
- 使用不当会产生死锁

## 5.2 redis
内部不包含一致性算法，实现的AP模型，采用主从复制机制实现高可用，表现形式为setNX。Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。

当且仅当key不存在，将key的值设为value。若给定的key已经存在，则SETNX不做任何动SETNX是『SET if Not eXists』(如果不存在，则SET)的简写。返回值：设置成功，返回1。设置失败，返回0。

使用SETNX完成同步锁的流程及事项如下：
- 使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功
- 为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要**为该key设置一个“合理”的过期时间**
- 释放锁，使用DEL命令将锁数据删除

Redis官方站提出了一种权威的基于Redis实现分布式锁的方式名叫Redlock，此种方式比原先的单节点的方法更安全。它可以保证以下特性：
1. 安全特性：互斥访问，即永远只有一个client能拿到锁
2. 避免死锁：最终client都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的client crash了或者出现了网络分区
3. 容错性：只要大部分Redis节点存活就可以正常提供服务

## 5.3 zookeeper
ZooKeeper用于为分布式应用提供一致性服务，内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。内部采用paxos算法，实现的CP模型，采用N+1可用的方式，表现形式为createEphemeral。

使用 Zookeeper 实现分布式锁步骤如下：
- 创建一个目录mylock
- 想获取锁的线程在mylock下创建临时顺序节点，同时获取mylock目录下所有的子节点，获取比自己小的兄弟节点，若不存在则获得锁，否则监听排序仅比自己靠前的那个节点
- 线程处理完会删除自己的节点，排序仅比它靠后的那个节点监听变更事件，判断自己是否为最小的节点，如果是则获得锁

## 5.4 etcd
内部采用raft协议，可以实现CP/AP模型，采用N+1可用的方式，对外提供http/grpc接口，表现形式为resuflt api。

# 六、分布式锁使用的特殊场景
从获得锁到释放锁中间的数据密等等逻辑需要根据业务实践，例如线程A操作订单，先拿到锁，操作之后修改订单状态，然后释放锁。线程B再来操作订单时，可以拿到锁，但是订单状态已经改变了就不进行操作，此时释放锁，通过这样的方式实现数据密等性的问题。