# 什么是分布式事务
事务大家都比较了解，对于一系列操作，所有操作要么全部执行完成，要么所有更改都会被撤销。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为[[ACID]]特性。

那么什么是分布式事务呢？分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。例如在大型电商系统中，下单接口通常会扣减库存、减去优惠、生成订单 id, 而订单服务与库存、优惠、订单 id 都是不同的服务，下单接口的成功与否，不仅取决于本地的 db 操作，而且依赖第三方系统的结果，这时候分布式事务就保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

# 数据一致性
## 强一致性
任何一次读都能读到某个数据的最近一次写的数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任意时刻，所有节点中的数据是一样的。

## 弱一致性
数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。

## 最终一致性
不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，就是在一段时间后，节点间的数据会最终达到一致状态。

# 分布式事务分类
# 柔性事务
不同于ACID的刚性事务，在分布式场景下基于[[BASE理论]]，就出现了柔性事务的概念，最终实现的是AP模型。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样；但是都不满足的话，是不可能做柔性事务的。典型的实现方式包括[[TCC模型]]和[[Saga模型]]。

# 刚性事务
刚性分布式事务满足传统分布式事务特性ACID(原子性，一致性，隔离性，持久性)。采用的是[[XA模型]]最终实现的CP模型。

## 缺点
- 同步阻塞模型
- 数据库资源锁定时间过长
- 全局锁，并发低
- 不适合长事务场景（分布式事务）

# 分布式事务的对比
![](https://tva1.sinaimg.cn/large/008eGmZEgy1gndlm1mfbcj30we0g0mzv.jpg)

# 分布式事务解决方案
## 两阶段提交/XA
[[XA模型]]

## TCC模型
[[TCC模型]]

## 本地消息表
本地消息表这个方案最初是ebay架构师Dan Pritchett在2008年发表在ACM的文章。该方案中会有消息生产者与消费者两个角色，假设系统A是消息生产者，系统B是消息消费者，其大致流程如下：
![](https://tva1.sinaimg.cn/large/008eGmZEgy1gndlxni4yxj30xc0feq51.jpg)
1.  当系统A被其他系统调用发生数据库表更新操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中
2.  系统A的脚本定期轮询本地消息往mq中写入一条消息，如果消息发送失败会进行重试
3.  系统B消费mq中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费mq中的消息进行重试，如果业务上的失败，可以通知系统A进行回滚操作

本地消息表实现的条件：
1.  消费者与生成者的接口都要支持幂等
2.  生产者需要额外的创建消息表
3.  需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作

容错机制：
1.  步骤1失败时，事务直接回滚
2.  步骤2、3写mq与消费mq失败会进行重试
3.  步骤3业务失败系统B向系统A发起事务回滚操作

此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。

## 可靠消息最终一致性
大致流程如下：
![](https://tva1.sinaimg.cn/large/008eGmZEgy1gndm0e13tfj315w0o443c.jpg)

1. A 系统先向 mq 发送一条 prepare 消息，如果 prepare 消息发送失败，则直接取消操作
2. 如果消息发送成功，则执行本地事务
3. 如果本地事务执行成功，则想 mq 发送一条 confirm 消息，如果发送失败，则发送回滚消息
4. B 系统定期消费 mq 中的 confirm 消息，执行本地事务，并发送 ack 消息。如果 B 系统中的本地事务失败，会一直不断重试，如果是业务失败，会向 A 系统发起回滚请求
5. mq 会定期轮询所有 prepared 消息调用系统 A 提供的接口查询消息的处理情况，如果该 prepare 消息本地事务处理成功，则重新发送 confirm 消息，否则直接回滚该消息

该方案与本地消息最大的不同是去掉了本地消息表，其次本地消息表依赖消息表重试写入 mq 这一步由本方案中的轮询 prepare 消息状态来重试或者回滚该消息替代。其实现条件与余容错方案基本一致。目前市面上实现该方案的只有阿里的 RocketMq。

## 尽最大努力通知
最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果 不影响主动方的处理结果。

这个方案的大致意思就是：
1.  系统 A 本地事务执行完之后，发送个消息到 MQ；
2.  这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；
3.  要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃。

# 参考文献
- [小米信息部技术团队](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)