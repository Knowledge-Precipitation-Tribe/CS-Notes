# 什么是粘包问题
TCP是个流协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

# 造成粘包的原因
## 发送方原因
TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：
- 只有上一个分组得到确认，才会发送下一个分组
- 收集多个小分组，在一个确认到来时一起发送  

Nagle 算法是一种通过减少数据包的方式提高TCP传输性能的算法。因为网络带宽有限，它不会将小的数据块直接发送到目的主机，而是会在本地缓冲区中等待更多待发送的数据，这种批量发送数据的策略虽然会影响实时性和网络延迟，但是能够降低网络拥堵的可能性并减少额外开销。

当应用层协议通过TCP协议传输数据时，实际上待发送的数据先被写入了TCP协议的缓冲区，如果用户开启了Nagle算法，那么TCP协议可能不会立刻发送写入的数据，它会等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被ACK时才会发送缓冲区中的数据。但是现在网络带宽资源已经没有那么紧张了，所以Linux内核一般都会默认关闭Nagle算法。

Nagle算法确实能够在数据包较小时提高网络带宽的利用率并减少TCP和IP协议头带来的额外开销，但是使用该算法也可能会导致应用层协议多次写入的数据被合并或者拆分发送，当接收方从TCP协议栈中读取数据时会发现不相关的数据出现在了同一个数据段中，应用层协议可能没有办法对它们进行拆分和重组。

## 接收方原因
TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

# 如何解决粘包问题
既然TCP协议是基于字节流的，也就意味着应用层协议要自己划分消息的边界。如果我们能在应用层协议中定义消息的边界，那么无论 TCP 协议如何对应用层协议的数据包进程拆分和重组，接收方都能根据协议的规则恢复对应的消息。在应用层协议中，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）。

基于长度的实现有两种方式，一种是使用**固定长度**，所有的应用层消息都使用统一的大小，另一种方式是使用**不固定长度**，但是需要在应用层协议的协议头中增加表示负载长度的字段，这样接收方才可以从字节流中分离出不同的消息，HTTP协议的消息边界就是基于长度实现的：

```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 138
...
Connection: close

<html>
  <head>
    <title>An Example Page</title>
  </head>
  <body>
    <p>Hello World, this is a very simple HTML document.</p>
  </body>
</html>
```

在上述HTTP消息中，我们使用`Content-Length`头表示HTTP消息的负载大小，当应用层协议解析到足够的字节数后，就能从中分离出完整的HTTP消息，无论发送方如何处理对应的数据包，我们都可以遵循这一规则完成HTTP消息的重组。

不过HTTP协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当HTTP使用块传输（Chunked Transfer）机制时，HTTP头中就不再包含`Content-Length`了，它会使用负载大小为0的HTTP消息作为终结符表示消息的边界。

当然除了这两种方式之外，我们可以基于特定的规则实现消息的边界，例如：使用TCP协议发送JSON数据，接收方可以根据接收到的数据是否能够被解析成合法的JSON判断消息是否终结。


# 推荐阅读
- [为什么TCP协议有粘包问题](https://draveness.me/whys-the-design-tcp-message-frame/)