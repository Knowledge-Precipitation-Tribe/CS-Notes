# 四次挥手流程
TCP断开连接是通过四次挥手实现的，而且客户端与服务器双方都可以主动断开连接。下面以客户端主动断开连接为例。

![](https://tva1.sinaimg.cn/large/008eGmZEgy1go9yqyairdj30u00v641u.jpg)

- 客户端打算关闭连接，此时会发送一个TCP首部FIN标志位被置为1的报文，也即FIN报文，之后客户端进入FIN_WAIT_1状态
- 服务端收到该报文后，就向客户端发送ACK应答报文，接着服务端进入CLOSED_WAIT状态
- 客户端收到服务端的ACK应答报文后，之后进入FIN_WAIT_2状态
- 等待服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态
- 客户端收到服务端的FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态
- 服务器收到了ACK应答报文后，就进入了CLOSED状态，至此服务端已经完成连接的关闭
- 客户端在经过2MSL一段时间后，自动进入CLOSED状态，至此客户端也完成连接的关闭

# 为什么需要四次挥手
- 关闭连接时，客户端发送FIN报文到服务端仅仅代表客户端不再发送数据了，但是还能接收数据
- 服务端收到客户端的FIN报文时，先回一个ACK应答报文，而服务端可能还有一些数据需要处理和发送，等服务端不再发送数据时，才发送FIN报文给客户端

# 为什么TIME_WAIT的等待时间是2MSL
TIME_WAIT等待2倍的[[MSL与TTL#^aaa635|MSL]]，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待2倍的时间。

比如如果被动关闭方没有收到断开连接的最后的ACK报文，就会触发超时重发Fin报文，另一方接收 到FIN后，会重发ACK给被动关闭方，一来一去正好2个MSL。

2MSL的时间是从客户端接收到FIN后发送ACK开始计时的。如果在TIME-WAIT时间内，因为客户端的 ACK没有传输到服务端，客户端又接收到了服务端重发的FIN报文，那么2MSL时间将重新计时。在Linux系统中，MSL默认是30秒。

# 为什么需要TIME_WAIT状态
主动发起关闭连接的一方才有TIME_WAIT状态。需要TIME_WAIT状态主要有以下原因：
- 防止具有相同四元组的旧数据包被收到。经过2MSL这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的
- 保证被动关闭连接的一方能被正确的关闭，即保证最后的ACK能让被动关闭方接收，从而帮助其正常关闭。假如TIME_WAIT没有等待时间或者等待时间过短，可能会导致以下问题：
	- 四次挥手的最后一个ACK报文如果在网络中被丢失，此时客户端TIME-WAIT时间过短或没有，则就直接进入了CLOSED状态，那么服务端就会一直处于LASE_ACK状态
	- 客户端发起新的SYN请求建立连接，服务端会发送RST报文给客户端，使得其无法创建新的连接

# 为什么TIME_WAIT不能过多
如果服务器有处于TIME_WAIT状态的TCP，则说明是服务器主动发起的断开请求。过多的TIME_WAIT主要有以下两种危害：
- 内存资源占用
- 对端口资源占用，一个TCP连接至少消耗一个本地端口

