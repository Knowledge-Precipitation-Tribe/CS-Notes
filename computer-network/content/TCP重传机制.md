在TCP传输中，当发送端的数据到达接收主机时，接收端会返回一个确认应答消息，表示已经介绍到消息，但是总会因为一些原因导致丢包，针对这种情况可以利用重传机制解决。

# 超时重传
在发送数据时，设定一个计时器，当超过指定时间后没有收到对方的ACK确认应答报文，就会重传该数据。有以下两种情况会触发超时重传：
- 数据包丢失
- 确认应答丢失

对于[[RTT与RTO#^f43fa6|RTO]]超时重传时间的设置其应该略大于[[RTT与RTO#^dae60a|RTT]]，如果RTO过大，数据包已经丢失较久才重新发送，没有效率，性能较差。如果RTO过小则增加了许多没有必要的重传。

在Linux下RTO的计算是这样的：需要TCP通过采样RTT的时间，然后进行加权平均，算出一个平滑RTT的值，而且这个值还是要不断变化的，因为网络状况不断地变化。除了采样RTT，还要采样RTT的波动范围，这样就避免如果RTT有一个大的波动的话，很难被发现的情况。

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP的策略是超时间隔加倍。

# 快速重传
对于快速重传他不是以时间为驱动的，而是以数据为驱动。
![](https://tva1.sinaimg.cn/large/008eGmZEgy1goa38e9lsyj30js0iaq4d.jpg)

- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- 发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。
- 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。因为没法确认连续的三个seq2都是谁传回来的