# 什么是死锁
由于多个程序的并发执行，改善了系统资源的利用率，并提高了系统的处理能力。然后由于多个进程因竞争系统资源或相互通信而处于永久阻塞状态时，若无外力作用，这些进程都将无法向前推进。每个进程都在等待其他线程正在占有的，但是自己却永远无法得到的资源，这种现象称为死锁。

# 死锁产生的原因
死锁产生的原因是竞争资源，若系统中的资源不足以同时满足所有进程的需要，则会产生进程对资源的竞争，从而导致可能产生死锁。

对于系统资源来说一般分为以下两类：
- 可剥夺资源：可剥夺资源是指虽然资源占有者进程需要使用该资源，但另一个进程可以强行把该资源从占有者进程处剥夺来归自己使用。
- 不可剥夺资源：不可剥夺资源是指除占有者进程不再需要使用该资源而主动释放时，其他进程不可以在占有者进程中强行剥夺。

而一个资源是否属于可剥夺资源，完全取决于资源本身的性质。例如打印机在打印任务结束之前是无法被其他任务剥夺的。

# 死锁产生的必要条件
死锁产生的必要条件有以下四条：
- 互斥条件：进程要求对所有分配的资源进行排他性控制，即在一段时间内某种资源仅为一个进程所占有
- 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放
- 请求与保持条件：进程每次申请它所需的一部分资源。在等待分配资源的同时。进程继续占有已经分配到的资源。
- 环路等待条件：存在一种进程资源的循环等待链，而链中的每一个进程已经获得的资源同时被链中的下一个进程所请求

如果要产生死锁，以上四个条件缺一不可。

# 处理死锁的办法
## 鸵鸟算法
像鸵鸟一样对死锁视而不见，不处理死锁

## 预防死锁
通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个来预防死锁的产生。

### 互斥条件
为了破坏互斥条件，就要允许多个进程同时访问资源。但是这会受到资源本身固有特性的限制，有些资源根本不能同时访问，只能互斥访问，如打印机就不允许多个进程在其运行期间交替打印数据，只能互斥使用。

### 不剥夺条件
为了破坏不剥夺条件，可以指定这样的策略：对于一个已经获得了某些资源的进程，若新的资源请求不能立即得到满足，则它必须释放所有已经获得的资源，以后需要资源时再重新申请。这就意味着一个进程已获得的资源在运行过程中可以被剥夺，从而破坏了不剥夺条件。该策略实现起来比较复杂，释放已获得的资源可能造成前一段工作的失效，重复申请和释放资源会增加系统开销，降低系统吞吐量。

### 请求与保持条件
为了破坏请求与保持条件，可以采用预先静态分配方法。预先静态分配法要求进程在其运行之前一次性申请所需要的全部资源，在它的资源未被满足之前，不投入运行。一旦投入运行后，这些资源就一直归他所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。

这种方式既简单又安全，但是页降低了资源的利用率，因为采用这种方法必须实现知道该作业所需要的全部资源，即使有的资源只能在运行后期使用，甚至有的资源在正常运行中根本不用，也不得不预先统一申请，结果导致系统资源不能充分利用。

### 环路等待条件
为了破坏环路等待条件，可以采用有序资源分配法。有序资源分配法是将系统中的所有资源都按类型赋予编号，要求每一个进程均严格按照编号递增的次序请求资源，也就是说只要进程请求来3好资源，则之后的请求不能再请求3号之前的其他资源。

这种方法由于对各种资源编号后不宜修改，从而限制了新设备的增加；而且不同作业对资源使用顺序也不完全相同，会导致资源的浪费。

## 避免死锁
预防死锁的方法中采用的集中策略都添加了比较强的约束条件，虽然实现起来较为简单，但是却严重损害了系统的性能。

在避免死锁中，施加的限制条件较弱，有可能获得较好的系统性能。在资源的动态分配过程中，预知系统是否会进入**不安全状态**，若该资源分配有可能产生死锁，则不进行分配，从而避免死锁的产生。

### 安全状态与不安全状态
若在某一时刻，系统能按照某种顺序来为每个进程分配其所需的资源，直至最大需求，使每个进程都可顺利完成，则称此时的系统状态为安全状态，称该序列为安全序列。若某一时刻系统中不存在这样的一个安全序列，则称此时的系统状态为不安全状态。而且安全序列在某一时刻可能并不位移，即可以同时存在多种安全序列。

虽然并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。

需要注意的是：
- 不安全状态不是指系统中已经产生死锁。不安全状态是指系统可能发生死锁状态。
- 处于不安全状态不是指系统必然会产生死锁。

对于避免死锁有一种比较代表性的算法，就是[[银行家算法]]


## 检测及解除死锁
通过系统的检测机构及时检测出死锁的发生，然后采取某种措施解除死锁。

