# 什么是进程
进程的定义众说纷纭，这里可以定义进程为程序在处理器上的一次执行过程。

# 为什么需要进程
进程是资源分配的基本单位

# 进程的组成
- 进程控制块PCB：每个进程均有一个PCB，系统根据PCB感知进程的存在，PCB是进程存在的唯一标志。
	- 进程标识符PID：每个进程都有唯一的进程标识符，以区别系统内部的其他进程。
	- 进程当前状态：说明进程的当前状态，以作为进程调度程序分配处理器的依据。
	- 进程队列指针：用于记录PCB队列中下一个PCB的地址。系统中的PCB可能有多个队列，如就绪队列，阻塞队列等。
	- 程序和数据地址：指出进程的程序和数据所在的地址。
	- 进程优先级：反应进程要求CPU的紧迫程度。
	- CPU现场保护区：当进程因某种原因释放处理器时，CPU现场信息(如指令计数器，状态寄存器，通用寄存器等)被保存在PCB的该区域中，以便进程重新获得处理器后能继续执行。
	- 通信信息：记录进程在执行过程中与别的进程所发生的信息交换情况。
	- 家族联系：有的系统允许进程创建子进程，从而形成一个进程家族树。
	- 占有资源清单：进程所需资源及当前已分配资源清单。
- 程序段：是指进程中能被进程调度程序调度到cpu上执行的程序代码段，能实现相应的特定功能。
- 数据段：一个进程的数据段可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或结果数据。

在一个系统中，通常存在很多进程，有的处于就绪态，有的处于阻塞态，而且阻塞原因各不相同，为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来，目前常用的组织方式有链接方式和索引方式。

# 进程的状态与转换
## 进程的基本状态
- 就绪状态：进程已获得除了处理器以外的所有资源，一旦获得处理器，就可以立即执行。
- 执行状态：一个进程获得了必要的资源并正在CPU上执行时，该进程就为执行态。
- 阻塞状态：正在执行的进程，由于发生某事件而暂时无法执行下去(如等待IO完成)，此时进程所处的状态为阻塞状态。
- 创建状态：进程正在被创建，尚未转到就绪状态。申请空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所需要的资源；最后把该进程转为就绪状态。
- 结束状态：进程正在从系统中消失，可能是正常结束或其他原因中断退出运行。

## 进程状态的转换
进程并非固定的处于某一种状态，其状态会随着自身的推进和外界条件的变化而发生变化。下图展示了几种状态的转换图。
![](https://tva1.sinaimg.cn/large/008eGmZEly1gntsli6rxyj30a003wt8t.jpg)

对于进程的状态转换有以下几点需要注意：
- 进程状态的转换并非都是可逆的，进程既不能从阻塞状态变为执行状态，也不能从就绪状态变为阻塞状态。
- 进程之间的状态转换并非都是主动的，在很多情况下都是被动的，只有从执行状态到阻塞状态是程序的自我行为(因时间而主动调用阻塞原语)，其他都是被动的。例如，从执行态到就绪态通常是时钟中断导致的(时间片用完)。
- 进程状态的唯一性，一个具体的形成在和一个执行的时刻必须且只能处于一种状态。

# 进程的切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：  
1. 保存处理机上下文，包括程序计数器和其他寄存器。  
2. 更新PCB信息。  
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。  
4. 选择另一个进程执行，并更新其PCB。  
5. 更新内存管理的数据结构。  
6. 恢复处理机上下文。

# 进程阻塞
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。

# 进程通信
进程通信是指进程之间的信息交换，目前高级进程通信包括以下三种方式
## 共享存储器系统（共享内存）
为了传输大量数据，在存储器中划出一块共享存储区，多个进程可以通过对共享存储区进行读写实现通信。在通信前，进程向系统申请建立一个共享存储区，并指定该共享存储区的关键字。若该共享存储区已经建立，则将该共享存储区的描述符返回给申请者。然后，申请者把获得的共享存储区附接到进程上。这样，进程便可以像读写普通存储器一样读写共享存储区了。

## 消息传递系统
在消息传递系统中，进程间以消息为单位交换数据，用户直接利用系统提供的一组通信命令来实现通信。操作系统隐藏了通信的实现细节，简化了通信程序，得到了广应用，根据实现方式的不同，消息传递可以分为以下两类。
- 直接通信方式。发送进程把消息直接发送给接受进程，并将它挂在接受进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息
- 间接通信方式。发送进程把消息发送到某个中间实体中，接收进程从中取得消息。

## 管道通信系统
管道是用于连接读进程和写进程以实现他们之间通信的共享文件，向管道提供输入的发送进程以字节流的形式将大量的数据送入管道，而接收管道输出的进程可以从管道中接收数据。管道一般来说是一个共享文件，不能单纯的从字面上理解它为一个传输管道。

# 相关概念
我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束。当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

## 孤儿进程
孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会处理它的一切善后工作。**因此孤儿进程并不会有什么危害。**

## 僵尸进程
一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。

unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait/waitpid来取时才释放。 但这样就导致了问题，**如果进程不调用wait/waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免**。

## 守护进程
Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。

守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。

一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。

守护进程的名称通常以d结尾，比如sshd、xinetd、crond等