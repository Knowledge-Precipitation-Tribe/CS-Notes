# 什么是写时复制机制(copy-on-write)
写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。

# 前置知识
## fork函数
fork函数主要用于创建子进程(相当于当前进程的副本)，在Linux中进程都是通过init进程或init的子进程fork出来的。当一个fork函数被调用时，该函数会有两次返回值：
- 对于父进程它会返回子进程的PID
- 对于子进程它会返回0或者负数(如果是负数的话则说明子进程创建失败)

当前进程调用fork后会创建一个除了pid不同其他完全形同的子进程。

## exec函数
exec函数的作用是装在一个新的程序覆盖当前进程内存空间中的映像，从而执行不同的任务。

# Linux中的COW
正常来说通过fork函数创建子进程后，会直接将父进程的数据拷贝到子进程中，拷贝完成之后，副进程和子进程之间的数据段和堆栈是相互独立的。但是对于fork的子进程来说一般都会调用exec函数来执行自己的逻辑，所以将父进程的数据拷贝过去可能是没有用的，既然很多时候复制给子进程的数据是无效的，于是就有了COW技术，原理如下：
- fork出来的子进程与父进程共享内存空间，也就是说如果子进程对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程，这样创建子进程的速度就比较快了。
- 当父进程中更改相应段的操作时，再为子进程分配相应的物理空间

更详细来说：fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会**把触发的异常的页复制一份**，于是父子进程各自持有独立的一份。

# COW的优点
- COW技术可**减少**分配和复制大量资源时带来的**瞬间延时**。
- COW技术可减少**不必要的资源分配**。比如fork进程时，并不是所有的页面都需要复制，父进程的**代码段和只读数据段都不被允许修改，所以无需复制**。

# COW的缺点
- 如果在fork()之后，父子进程都还需要继续进行写操作，**那么会产生大量的分页错误(页异常中断page-fault)**，这样就得不偿失。

# Redis中的COW
- Redis在持久化时，如果是采用BGSAVE命令或者BGREWRITEAOF的方式，那Redis会**fork出一个子进程来读取数据，从而写到磁盘中**。
- 总体来看，Redis还是读操作比较多。如果子进程存在期间，发生了大量的写操作，那可能就会出现**很多的分页错误(页异常中断page-fault)**，这样就得耗费不少性能在复制上。
- 而在**rehash阶段上，写操作是无法避免**的。所以Redis在fork出子进程之后，**将负载因子阈值提高**，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存。

# 参考文献
- [COW奶牛！Copy On Write机制了解一下](https://juejin.cn/post/6844903702373859335)