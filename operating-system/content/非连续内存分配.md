# 什么是非连续内存分配
非连续内存分配**允许一个程序分散的装入到不相邻的内存分区中**。
非连续分配管理方式根据分区大小是否固定分为
- 分页存储管理方式。分页存储管理方式根据运行作业时是否需要把作业的所有页都装入内存才能运行而分为：
	- **基本分页存储管理**
	- **请求分页存储管理**
- 分段存储管理方式

# 基本分页存储管理方式
## 分页原理
在分页存储管理中，用户作业的地址空间被划分为若干个大小相等的区域，称为页或页面。相应的也将主存中的存储空间划分为与页面大小相等的区域，称为快或者物理块。在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中。

在调度作业运行时，必须将它的所有页面一次调入主存；若主存中没有足够的物理块，则作业等待。这种存储管理方式称为**简单分页或纯分页**。

页面的大小由机器的地址结构决定。在确定地址结构时，若选择的页面比较小，可使页内碎片较小并减少内存碎片的总空间，有利于提高内存利用率；但也会使每个进程要求较多的页面，从而导致页表过长，占用较多内存，还会降低页面换进换出的效率。若选择的页面较大，虽然可以减少页表长度，提高页面换进换出的效率，但却会使页内碎片增大。

因此，页面的大小应该选择适中（通常为2的整数幂），以方便地址变换，一般为512B～4KB。分页存储管理系统中的逻辑地址包含两部分内容：前一部分为页号P，后一部分为页内位移W（也称为页内偏移量）。

为了将逻辑地址上连续的页号映射到物理内存中后称为离散分布的多个物理块，需要将每个页面和每个物理块一一对应，这种映射关系就体现在**页表**上。页表中每个页表项都由页号和块号组成，根据页表项就可以找到每个页号所对应物理内存中物理块的块号。页表通常存放在内存中。

## 基本地址变换机构
地址变换过程是由硬件自动完成的，页表寄存器PTR用于存放页表在内存中的起始地址和页表长度。
![](https://tva1.sinaimg.cn/large/008eGmZEly1gnt5d06z2ij30ow0ec3zu.jpg)
如上图所示，假设页面大小为L，页表长度为M，逻辑地址为A，物理地址为E，下面列出从逻辑地址A得到物理地址E去访问内存的步骤。
- 计算页号p=(int)(A/L)，页内位移W=A%L
- 比较页号P和页表长度M，若p>=M，则产生越界中断，否则继续向下执行
- 页表其实地址F与页号P和页表项长度的乘积相加，用得到的地址值到内存中取出该内存单元存放的数b，这个b就是物理块号
- 物理块号b和物理块大小的乘积与页内位移W组合称物理地址E
- 用得到的物理地址E去访问内存

## 具有快表的地址变换机构
从上面可以知道，若页表全部存放在主存中，则存取一个数据或一条指令至少要访问两次主存。其中，第一次是通过访问页表以确定所存取的数据或指令的物理地址，第二次才根据所得到的物理地址存取数据或指令。

为了提高地址的变换速度，可以在地址变换机构中增设一个具有并行查找功能的高速缓冲存储器(又称为联想存储器或快表)	，将部分页表项放在这个高速缓冲存储器中。快表(TLB)一般由半导体存储其实现，其工作周期与CPU的周期大致相同，但造价较高。所以通常将正在运行作业当前访问的那些页表项存放在快表中，页表的其他部分仍然存放在内存中。如下图所示
![](https://tva1.sinaimg.cn/large/008eGmZEly1gnt5ahiuebj30j60bdmy2.jpg)

增加快表后的地址变换过程如下：
- 根据逻辑地址得到页号P与页内位移W
- 将页号与TLB中的页号进行对比，若有匹配的页号，则直接读取出对应的块号，与页内位移拼接得到对应的物理地址。若没有匹配的页号，则还需访问内存中的页表，从页表中取出物理块号，与页内位移拼接得到物理地址，并将此次的页表项存储到快表中
- 用得到的物理地址访问内存

## 页的共享和保护
分页存储管理系统中将作业的地址空间划分成页面的做法用户是无法操作的，同时作业的地址空间是现行连续的，当系统将作业的地址空间分成大小相同的页面时，被共享的部分不一定被包含在一个完整的页面中，这样不应该被共享的数据也被共享了，所以在分页系统中共享比较困难。

分页存储管理系统为内存提供了两种保护方式：
- 一种是地址越界保护，即通过比较地址变换机构中的页表长度和所需要访问的逻辑地址中的页号来完成
- 另一种通过页表中的访问控制信息对内存信息提供保护。例如添加读，写，执行等权限，在进行地址变换时，不仅要从页表中得到块号，还要检查本次操作与存取控制字段允许的操作是否相等。

## 基本分页存储管理方式的优缺点
- 优点
	- 内存利用率高
	- 实现了离散分配
	- 便于存储访问控制
	- 无外部碎片
- 缺点
	- 需要硬件支持(尤其是快表)
	- 内存访问效率下降
	- 共享困难
	- 无内部碎片

# 基本分段管理方式
在前面介绍的存储技术中，用户逻辑地址空间要求是一个线性连续的地址空间，而通常情况下，一个作业是由多个程序段和数据段组成的，这就要求编译链接程序将它们按照一维线性地址进行排列，这样使得程序和数据共享困难。

我们希望按照逻辑关系将作业分段，且每段要有自己的名字，以便于根据名字访问响应的程序段或数据段。分段存储管理能较好的解决上述问题。因此，分段存储管理相较于分页存储管理有以下优点。
- 方便编程：用户把自己的作业按照逻辑关系划分为若干个段，每段都是从0开始编址，有自己的名称和长度。
- 信息共享：页面是存放信息的物理单位，没有完整的意义；而段是信息的逻辑单位，用户可以把需要共享的部分代码和数据放在同一段以便信息共享。
- 信息保护：由于每一段都包含相对独立的信息，因此对信息保护可以采取对段进行保护，信息保护相对于分页式更方便

## 分段存储原理
在分段存储管理系统中，作业的地址空间由若干个逻辑分段组成，每个分段是一组逻辑意义上相对完整的信息集合，每个分段都有自己的名字，每个分段都是从0开始编址，并采用一段连续的地址空间。因此，整个作业的地址空间是二维的(段的分类是一维，段内位移是另一维)。分段存储管理中以段为单位分配内存，每段分配一个连续的内存区，但各段之间不要求连续。内存的分配与回收类似于动态分区分配。分段存储管理系统的逻辑地址结构由段号和段内位移(也称段内偏移)组成。

## 段表及地址变换过程
为了实现从逻辑地址到物理地址的变换，系统为每个进程建立了一个段表，其中每个表项描述一个分段的信息，表项中包含段号，段长和该段的内存起始地址。通过段表，执行中的进程可以通过查找段表，找到每个段对应的内存区域，实现从逻辑段到物理内存区的映射。

![](https://tva1.sinaimg.cn/large/008eGmZEly1gnzwqeeg5nj309i043t90.jpg)

在进行地址变换时，系统将逻辑地址中的段号与段表长度进行比较，若段号超过了段表长度，则表示段号越界，就会产生越界中断；否则就会根据段表起始地址和段号计算出该段对应段表项的位置，从中读取出该段在内存中的起始地址，然后检查段内位移是否超过该段段长，若超过，则同样产生越界中断；否则将该段的起始地址与段内位移相加，从而得到要访问的物理地址。为了提高内存的访问速度，也可以使用快表，地址变换过程都是由硬件自动完成的。

![](https://tva1.sinaimg.cn/large/008eGmZEly1gnzwy51zelj30ha0d6aba.jpg)

从逻辑地址到物理地址的过程如下：
- 从逻辑地址A中取出前几位做为段号S，后几位作为段内位移W
- 比较段号S和段表长度M，若S>=M，则产生越界中断，否则继续执行
- 取出段表起始地址F和段号S，使其相加，用得到的地址值到内存中取出该内存单元存放的数，取出来的前几位是段长C，后几位是段的起始地址(基址)b，若段内位移W>=C，则产生越界中断，否则继续执行
- 段的基址b和段内位移W相加得到物理地址E
- 用得到的物理地址E去访问内存

## 段的共享与保护
现阶段我们一般会讲程序分为代码区和数据区，不能修改的代码可以称为只读代码段，这样不能修改的数据是可以共享的。

分段管理的保护主要有两种：
- 越界地址保护。有一些系统允许段动态增长，这时段内位移大于段长是允许的，但是需要在段表中设置相应的标识来指示段是否允许动态增长
- 访问控制保护

## 基本分段存储管理方式的优缺点
优点：
- 便于程序模块化处理
- 便于动态链接和共享
- 无内部碎片

缺点：
- 需要硬件支持
- 为满足分段的动态增长和减少外部碎片，要采用拼接技术
- 分段的最大尺寸收到主存可用空间的限制
- 有外部碎片

# 分段与分页的区别
- 页是信息的物理单位，分页是为了实现离散分配方式，以减少内存的碎片，提高内存利用率。段是信息的逻辑单位，它含有一组意义相对完整的信息，分段是为了更好的满足用户的需要。
- 页的大小固定，且由系统决定。段的长度不固定，是由用户所编写的程序决定，通常由辨析系统对源程序进行编译时根据信息的性质来划分。

# 基本段页式存储管理
分页系统能有效的提高内存利用率并且能解决碎片的问题，而分段系统能反应程序的逻辑结构并由利于段的共享，将这两种方式结合起来就组成了段页式存储管理方式。

在段页式存储管理系统中，作业的地址空间首先被分为若干个逻辑分段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对于主存空间仍然和分页管理一样，将其分成若干个和页面大小相同的物理块，对主存的分配以物理块为单位。

段页式存储管理系统的逻辑地址结构分为三部分：段号，段内页号，页内位移。为了实现地址转换，段页式存储管理系统中需要同时设立段表和页表。系统为每个进程建立一张段表，而每个分段有一张页表。段表的表项中至少应该包括段号，页表起始地址和页表长度，其中页表起始地址代表该段在主存中的起始地址，页表的表项中至少应包包括页号和块号。此外，为了便于实现地址的转换，系统还需要配置一个段表寄存器，用来存放段表的起始地址和段表长度。

![](https://tva1.sinaimg.cn/large/008eGmZEly1gnzzdppzevj30og0bqwfp.jpg)

从逻辑地址到物理地址的转换如下：
- 从逻辑地址A中取出前几位为段号S，中间几位为页号P，后几位为页内位移W
- 比较段号S和段表长度M，若S>M，则产生越界中断，否则继续执行
- 取出段表起始地址F与段号S相加，用得到的地址值在内存中读取出该内存单元存放的数，取出该数的前几位为页表长度C，后几位是页表的起始地址d，若页号P>C，则产生越界中断，否则继续执行
- 页表其实地址d与页号P和页表项长度的乘积相加得到页表项在内存中的物理地址，查找到该地址存放的数值为物理块号b。
- 用物理块号b+页内位移W组合成物理地址E
- 用得到的物理地址E去访问内存

**虽然段页式结合了段式和页式的优点，但是段页式的内部碎片并不是和页式一样少**。